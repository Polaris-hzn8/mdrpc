# rpc远程过程调用

---

### 1.网络IO模型

1. accpet + read/write

2. accept + fork（process pre connection）

3. accept + thread（thread pre connection）

4. muduo：reactors in threads（one loop per thread）

   主反应堆负责accept连接然后分发到多个sub reactor中，该连接的所有操作都在sub reactor所处的线程中完成，多个连接可能被分派到多个线程中，以充分利用CPU资源。

5. nginx：reactors in process（one loop per process）

   nginx服务器的网络模块基于进程设计，采用多个Reactors充当IO进程和工作进程，通过accept锁解决多个Reactors的惊群现象。

### 2.RPC远程过程调用

- 绿色部分（序列化/反序列化）：涉及RPC方法参数的打包和解析，利用protobuf实现
- 黄色部分（数据传输网络部分）：网络传输部分，包括寻找rpc服务主机、发起rpc调用请求和响应rpc调用结果，使用muduo网络库实现。

![image-20251228001313420](assets/image-20251228001313420.png)

rpc主要工作：

1. 服务发现：查找机器上的远程rpc方法（zookeeper服务配置中心）
2. 服务请求：通过网络调用函数标识、函数参数，将请求通过网络库发送出去
3. 服务响应：将请求返回结果返回给请求方

### 3.将本地服务发布成PRC服务

通过此框架可以将上层应用的本地方法，快速的部署成PRC方法，框架不处理任何业务。

1. 用户如何注册rpc服务？
2. 网络框架如何存储rpc服务？

#### rpc服务方法提供

##### 服务与方法存储

接收到rpc调用请求后，如何知道调用方需要调用应用程序的，哪个服务、以及调用对应服务的具体哪个rpc方法？需要生产一张表，记录服务对象和其发布的所有的服务方法。Service类用于描述对象，Method类用于描述方法：

notifyService：

记录服务对象和其发布的所有rpc方法：

- UserService：Login、Register
- FriendService：AddFriend、DelFriend、GetFriendList

```cpp
// 将UserService对象发布到rpc服务节点上
// 注册UserService服务对象
MdrpcProvider providor;
providor.RegisterService(new UserService());
```

##### 服务与方法注册发布

建立了一个rpc服务器，并在rpc服务器上发布了一系列的rpc服务与方法，提供给请求方进行调用。

```cpp
// 保存服务对象和服务方法的映射表
struct ServiceInfo {
    // 保存服务对象
    google::protobuf::Service* _service;
    // 保存服务方法名称和服务方法描述符的映射表
    std::unordered_map<std::string, const google::protobuf::MethodDescriptor*> _method_map;
};
// 存储注册成功的服务对象和服务方法
std::unordered_map<std::string, ServiceInfo> _service_map;
// 注册发布rpc服务方法
void MdrpcProvider::RegisterService(google::protobuf::Service* service) {
    ServiceInfo service_info;
    service_info._service = service;
    service_info._method_map.clear();

    // 服务描述符
    const google::protobuf::ServiceDescriptor* sd = service->GetDescriptor();
    // 服务名称
    std::string service_name = sd->name();
    // 服务方法数量
    int method_count = sd->method_count();
    for (int i = 0; i < method_count; ++i) {
        // 服务方法描述符
        const google::protobuf::MethodDescriptor* md = sd->method(i);
        // 方法名称
        std::string method_name = md->name();
        // 存储服务方法名称和方法描述符的映射
        service_info._method_map.insert({method_name, md});
        std::cout << "Register method: " << method_name << " for service: " << service_name << std::endl;
    }
    _service_map.insert({service_name, service_info});
    std::cout << "Register service: " << service_name << " with " << method_count << " methods." << std::endl;
}
```







##### 具体方案使用

rpc服务方法的发布者：

1. 先在本地定义业务逻辑方法，例如登录login
2. 本地实现类继承自由pb生成的Service类，
3. 重写类中对应的虚函数方法
   - 获取rpc方法相关参数
   - 传入到本地的login方法中
   - 将相应结果封装序列化后，通过网络库发送出去

#### rpc服务方法请求

























